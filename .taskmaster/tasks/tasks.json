{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Node.js project and install tree-sitter-cli",
        "description": "Create the foundational Node.js project structure with package.json and install tree-sitter-cli as a dev dependency.",
        "details": "1. Run `npm init -y` to create package.json\n2. Run `npm install --save-dev tree-sitter-cli`\n3. Add build scripts to package.json:\n   ```json\n   \"scripts\": {\n     \"generate\": \"tree-sitter generate\",\n     \"build\": \"tree-sitter generate\",\n     \"test\": \"tree-sitter test\",\n     \"parse\": \"tree-sitter parse\"\n   }\n   ```\n4. Update .gitignore to include:\n   - `build/`\n   - `src/` (generated C files)\n   - `*.wasm`\n\nNote: tree-sitter-cli requires Node.js. The CLI will be used to generate the parser from grammar.js.",
        "testStrategy": "Verify package.json exists with correct dependencies. Run `npx tree-sitter --version` to confirm CLI is accessible. Run `npm run generate` after grammar.js exists to confirm build pipeline works.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T20:01:52.115Z"
      },
      {
        "id": "2",
        "title": "Create minimal tree-sitter grammar for comments",
        "description": "Create grammar.js with the minimum viable parser that handles AHK line comments (;) and block comments (/* */).",
        "details": "Create `grammar.js` at project root:\n```javascript\nmodule.exports = grammar({\n  name: 'autohotkey',\n\n  extras: $ => [\n    /\\s/,\n  ],\n\n  rules: {\n    source_file: $ => repeat($._statement),\n\n    _statement: $ => choice(\n      $.comment,\n      $.block_comment,\n      $._text,\n    ),\n\n    comment: $ => seq(\n      ';',\n      /.*/\n    ),\n\n    block_comment: $ => seq(\n      '/*',\n      /[^*]*\\*+([^/*][^*]*\\*+)*/,\n      '/'\n    ),\n\n    // Catch-all for non-comment text (temporary for MVP)\n    _text: $ => /[^;\\s\\/][^\\n]*/,\n  }\n});\n```\n\nThis minimal grammar:\n- Parses `;` as start of line comment, captures rest of line\n- Parses `/* ... */` block comments\n- Uses `_text` as catch-all for other content (prefixed with _ so it's hidden)\n- `extras` handles whitespace automatically",
        "testStrategy": "1. Run `npm run generate` - should complete without errors\n2. Create test file `test.ahk`:\n   ```ahk\n   ; This is a comment\n   /* Block\n   comment */\n   some code here\n   ```\n3. Run `npx tree-sitter parse test.ahk` - verify comments are recognized as `comment` and `block_comment` nodes\n4. Check generated `src/` directory contains parser.c",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T20:03:36.799Z"
      },
      {
        "id": "3",
        "title": "Create Zed extension manifest (extension.toml)",
        "description": "Create the extension.toml file that registers this as a Zed extension and declares the AutoHotkey language grammar.",
        "details": "Create `extension.toml` at project root:\n```toml\nid = \"autohotkey\"\nname = \"AutoHotkey\"\nversion = \"0.1.0\"\nschema_version = 1\nauthors = [\"Alfredo\"]\ndescription = \"AutoHotkey v1 language support for Zed\"\nrepository = \"https://github.com/Alfredo/tree-sitter-autohotkey\"\n\n[grammars.autohotkey]\nrepository = \".\"\npath = \".\"\n```\n\nThe `grammars.autohotkey` section tells Zed:\n- Grammar name is `autohotkey`\n- Source is in the current directory (local development)\n- Zed will look for `grammar.js` and run tree-sitter generate",
        "testStrategy": "Validate TOML syntax with an online validator or `npx toml-lint extension.toml`. Verify all required fields are present per Zed extension documentation.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T20:04:17.613Z"
      },
      {
        "id": "4",
        "title": "Create language configuration (config.toml)",
        "description": "Create the language config file that defines file associations, comment syntax, and other language-specific settings for Zed.",
        "details": "Create directory structure and file:\n1. `mkdir -p languages/autohotkey`\n2. Create `languages/autohotkey/config.toml`:\n```toml\nname = \"AutoHotkey\"\ngrammar = \"autohotkey\"\npath_suffixes = [\"ahk\"]\nline_comments = [\";\"]\nblock_comment = [\"/*\", \"*/\"]\nauto_indent_using_last_non_empty_line = true\n```\n\nKey settings:\n- `path_suffixes`: Associates `.ahk` files with this language\n- `line_comments`: Enables `;` for `gcc`/`Ctrl+/` comment toggling\n- `block_comment`: Enables `/* */` for block comment operations\n- Links to the `autohotkey` grammar from extension.toml",
        "testStrategy": "Validate TOML syntax. Verify file path is correct: `languages/autohotkey/config.toml`. Check that `line_comments` array uses the correct syntax for Zed.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T20:05:11.091Z"
      },
      {
        "id": "5",
        "title": "Create syntax highlighting queries (highlights.scm)",
        "description": "Create the Tree-sitter query file that maps parsed syntax nodes to Zed theme highlight groups for comments.",
        "details": "Create `languages/autohotkey/highlights.scm`:\n```scheme\n; Comments\n(comment) @comment\n(block_comment) @comment\n```\n\nThis minimal query:\n- Maps `comment` nodes (line comments) to the `@comment` highlight group\n- Maps `block_comment` nodes to the same `@comment` group\n- Zed themes define colors for `@comment` (typically gray/italic)\n\nNote: The node names must exactly match what grammar.js defines (case-sensitive).",
        "testStrategy": "1. Run `npx tree-sitter highlight test.ahk` to verify queries work\n2. Check that both `;` line comments and `/* */` block comments are highlighted\n3. Verify no query errors are reported",
        "priority": "high",
        "dependencies": [
          "2",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T20:05:59.144Z"
      },
      {
        "id": "6",
        "title": "Build grammar and install as Zed dev extension",
        "description": "Generate the parser, then install the extension locally in Zed to verify the MVP comment functionality works.",
        "details": "1. Generate parser: `npm run generate`\n   - Creates `src/parser.c`, `src/tree_sitter/parser.h`\n   - May create binding files\n\n2. Install as dev extension in Zed:\n   - Open Zed\n   - Open Command Palette (Cmd+Shift+P or Ctrl+Shift+P)\n   - Type \"Extensions: Install Dev Extension\"\n   - Navigate to `C:\\Users\\Alfredo\\Documents\\GitHub\\tree-sitter-autohotkey`\n   - Select the folder\n\n3. Reload Zed if necessary\n\n4. Open any `.ahk` file - should now have:\n   - Language detected as \"AutoHotkey\"\n   - Comments highlighted\n   - `gcc` (vim mode) toggles `;` comments\n   - `Ctrl+/` toggles `;` comments",
        "testStrategy": "1. Create `test.ahk` file with mixed content and comments\n2. Open in Zed, verify language shows as 'AutoHotkey' in status bar\n3. Test `gcc` in vim mode - should add/remove `;` prefix\n4. Test `Ctrl+/` - should toggle line comment\n5. Verify comment text appears in comment color (gray/green depending on theme)\n6. Check Zed logs via `zed --foreground` if issues occur",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T21:08:20.627Z"
      },
      {
        "id": "7",
        "title": "Add string and number parsing to grammar",
        "description": "Extend grammar.js to parse string literals (double and single quoted) and numbers (integers, hex, floats).",
        "details": "Update `grammar.js` to add string and number rules:\n```javascript\nmodule.exports = grammar({\n  name: 'autohotkey',\n\n  extras: $ => [/\\s/],\n\n  rules: {\n    source_file: $ => repeat($._statement),\n\n    _statement: $ => choice(\n      $.comment,\n      $.block_comment,\n      $.string,\n      $.number,\n      $._text,\n    ),\n\n    comment: $ => seq(';', /.*/),\n\n    block_comment: $ => seq(\n      '/*',\n      /[^*]*\\*+([^/*][^*]*\\*+)*/,\n      '/'\n    ),\n\n    string: $ => choice(\n      seq('\"', /[^\"]*/, '\"'),   // Double-quoted\n      seq(\"'\", /[^']*/, \"'\")    // Single-quoted\n    ),\n\n    number: $ => choice(\n      /0[xX][0-9a-fA-F]+/,       // Hex: 0xFF\n      /\\d+\\.\\d+/,                // Float: 3.14\n      /\\d+/                       // Integer: 123\n    ),\n\n    _text: $ => /[^;\\s\\/\"'0-9][^\\n]*/,\n  }\n});\n```\n\nUpdate `languages/autohotkey/highlights.scm`:\n```scheme\n(comment) @comment\n(block_comment) @comment\n(string) @string\n(number) @number\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Create test file:\n   ```ahk\n   x := \"hello world\"\n   y := 'single quoted'\n   num := 123\n   hex := 0xFF\n   pi := 3.14\n   ```\n3. Run `npx tree-sitter parse test.ahk` - verify strings/numbers are correctly identified\n4. Reload Zed extension and verify syntax highlighting for strings (usually green) and numbers (usually cyan/orange)",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T21:17:45.732Z"
      },
      {
        "id": "8",
        "title": "Add keyword recognition to grammar",
        "description": "Extend grammar.js to recognize AHK v1 keywords like if, else, while, loop, return, class, global, local, break, continue.",
        "details": "Update `grammar.js` to add keyword rules:\n```javascript\nmodule.exports = grammar({\n  name: 'autohotkey',\n\n  extras: $ => [/\\s/],\n  \n  word: $ => $.identifier,\n\n  rules: {\n    source_file: $ => repeat($._statement),\n\n    _statement: $ => choice(\n      $.comment,\n      $.block_comment,\n      $.string,\n      $.number,\n      $.keyword,\n      $.identifier,\n      $._text,\n    ),\n\n    // ... existing rules ...\n\n    keyword: $ => choice(\n      'if', 'else', 'while', 'loop', 'for',\n      'return', 'break', 'continue',\n      'class', 'extends',\n      'global', 'local', 'static',\n      'try', 'catch', 'finally', 'throw',\n      'new', 'true', 'false'\n    ),\n\n    identifier: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,\n    \n    _text: $ => /[^;\\s\\/\"'a-zA-Z0-9_][^\\n]*/,\n  }\n});\n```\n\nUpdate `languages/autohotkey/highlights.scm`:\n```scheme\n(comment) @comment\n(block_comment) @comment\n(string) @string\n(number) @number\n(keyword) @keyword\n(identifier) @variable\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Create test file:\n   ```ahk\n   if (x = 1) {\n       return true\n   } else {\n       global myVar\n       loop 10 {\n           break\n       }\n   }\n   ```\n3. Parse and verify keywords are recognized separately from identifiers\n4. Reload Zed - keywords should appear in keyword color (usually purple/blue)",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T21:20:54.035Z"
      },
      {
        "id": "9",
        "title": "Add function and label parsing to grammar",
        "description": "Extend grammar.js to parse function definitions, function calls, labels, and hotkeys.",
        "details": "Update `grammar.js` with function/label rules:\n```javascript\nrules: {\n  // ... existing rules ...\n\n  _statement: $ => choice(\n    $.comment,\n    $.block_comment,\n    $.function_definition,\n    $.function_call,\n    $.label,\n    $.hotkey,\n    $.directive,\n    $.string,\n    $.number,\n    $.keyword,\n    $.identifier,\n    $._text,\n  ),\n\n  function_definition: $ => seq(\n    field('name', $.identifier),\n    '(',\n    optional($.parameter_list),\n    ')',\n    '{',\n    repeat($._statement),\n    '}'\n  ),\n\n  function_call: $ => seq(\n    field('name', $.identifier),\n    '(',\n    optional($.argument_list),\n    ')'\n  ),\n\n  parameter_list: $ => seq(\n    $.identifier,\n    repeat(seq(',', $.identifier))\n  ),\n\n  argument_list: $ => seq(\n    $._expression,\n    repeat(seq(',', $._expression))\n  ),\n\n  _expression: $ => choice(\n    $.string,\n    $.number,\n    $.identifier\n  ),\n\n  label: $ => seq(\n    field('name', $.identifier),\n    ':',\n    /\\n/\n  ),\n\n  hotkey: $ => seq(\n    /[#!^+<>*~$]+/,\n    /[a-zA-Z0-9]+/,\n    '::'\n  ),\n\n  directive: $ => seq(\n    '#',\n    choice('Include', 'NoEnv', 'SingleInstance', 'Persistent')\n  ),\n}\n```\n\nUpdate `highlights.scm`:\n```scheme\n(function_definition name: (identifier) @function)\n(function_call name: (identifier) @function.call)\n(label name: (identifier) @label)\n(hotkey) @keyword.special\n(directive) @keyword.directive\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Create comprehensive test file:\n   ```ahk\n   #NoEnv\n   #SingleInstance Force\n   \n   MyFunc(param1, param2) {\n       return param1 + param2\n   }\n   \n   result := MyFunc(1, 2)\n   \n   MyLabel:\n       MsgBox, Hello\n   return\n   \n   ^a::\n       Send, test\n   return\n   ```\n3. Parse and verify all constructs are correctly identified\n4. Reload Zed and verify highlighting",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T21:25:06.029Z"
      },
      {
        "id": "12",
        "title": "Add doc-style block comments to grammar",
        "description": "Add support for documentation-style block comments (/** ... */) that are commonly used for function/class documentation.",
        "details": "Update `grammar.js` to add doc_comment rule:\n\n```javascript\ndoc_comment: $ => seq(\n  '/**',\n  /[^*]*\\*+([^/*][^*]*\\*+)*/,\n  '/'\n),\n```\n\nAdd to `_statement` choice before `block_comment`.\n\nUpdate `highlights.scm`:\n```scheme\n(doc_comment) @comment.documentation\n```\n\nNote: `@comment.documentation` may render differently in some themes (often bold or different color).",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   /**\n    * This is a doc comment\n    * @param x The x value\n    */\n   MyFunc(x) {\n   }\n   ```\n3. Verify doc comments parse as `doc_comment` nodes\n4. Verify highlighting in Zed",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T22:30:00.000Z"
      },
      {
        "id": "13",
        "title": "Add operators to grammar with highlighting",
        "description": "Parse operators as distinct tokens instead of generic punctuation. Includes assignment (:=), comparison (==, !=, <, >), arithmetic (+, -, *, /), and logical (&&, ||, !).",
        "details": "Update `grammar.js`:\n\n```javascript\noperator: $ => choice(\n  // Assignment\n  ':=', '+=', '-=', '*=', '/=', '.=',\n  // Comparison\n  '==', '!=', '<>', '>', '<', '>=', '<=',\n  // Arithmetic\n  '+', '-', '*', '/', '//', '**',\n  // Logical\n  '&&', '||', '!',\n  // Bitwise\n  '&', '|', '^', '~', '>>', '<<',\n  // Other\n  '.', '?', ':',\n),\n```\n\nRemove operators from `_punctuation` rule.\n\nUpdate `highlights.scm`:\n```scheme\n(operator) @operator\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   x := 1 + 2\n   y := x == 3 ? \"yes\" : \"no\"\n   z := a && b || !c\n   ```\n3. Verify operators are highlighted distinctly from variables",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-25T23:00:00.000Z"
      },
      {
        "id": "14",
        "title": "Add built-in commands to grammar",
        "description": "Recognize AHK v1 built-in commands like MsgBox, Send, Sleep, Run, WinActivate, etc. with proper highlighting.",
        "details": "Update `grammar.js` with command rule:\n\n```javascript\ncommand: $ => seq(\n  field('name', $.command_name),\n  optional(seq(',', $.command_args))\n),\n\ncommand_name: $ => choice(\n  'MsgBox', 'Send', 'SendInput', 'SendRaw',\n  'Sleep', 'Run', 'RunWait',\n  'WinActivate', 'WinWait', 'WinClose', 'WinExist',\n  'SetTimer', 'Gosub', 'Goto',\n  'FileRead', 'FileAppend', 'FileDelete',\n  'RegRead', 'RegWrite',\n  'InputBox', 'ToolTip', 'TrayTip',\n  'Reload', 'ExitApp', 'Suspend', 'Pause',\n  // Add more as needed\n),\n\ncommand_args: $ => /[^\\n]*/,\n```\n\nUpdate `highlights.scm`:\n```scheme\n(command_name) @function.builtin\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   MsgBox, Hello World\n   Sleep, 1000\n   Send, {Enter}\n   Run, notepad.exe\n   ```\n3. Verify commands highlight as built-in functions",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Test command parsing with tree-sitter CLI directly",
            "description": "Verify parser behavior outside of Zed by testing command parsing with tree-sitter CLI to isolate whether the issue is in the grammar or Zed integration",
            "dependencies": [],
            "details": "Create a test.ahk file with multiple commands (MsgBox, Sleep, Send, Run, WinActivate) and parse it using `npx tree-sitter parse test.ahk`. Compare which commands produce `command_name` nodes vs `identifier` nodes. If all commands parse correctly as `command_name` in CLI but not in Zed, the issue is Zed-side. If only MsgBox/Gui parse correctly in CLI too, the issue is in the grammar/parser itself.",
            "status": "done",
            "testStrategy": "Run `npx tree-sitter parse test.ahk` with commands: MsgBox, Sleep, Send, Run. Verify each command shows (command (command_name)) structure, not (identifier).",
            "updatedAt": "2025-12-26T15:04:03.482Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Compare grammars/autohotkey vs main src directories",
            "description": "Verify that Zed is using the correct parser.c by comparing the grammars/autohotkey checkout with the main src directory",
            "dependencies": [
              1
            ],
            "details": "The grammars/autohotkey directory contains a git checkout at commit bc2f634 but extension.toml rev points to the same commit. Verify the src/parser.c in both locations are identical using diff or checksum comparison. Check if grammars/autohotkey/src/grammar.json matches main src/grammar.json. Look for any discrepancies that could explain why only some commands work.",
            "status": "done",
            "testStrategy": "Run diff between grammars/autohotkey/src/parser.c and main src/parser.c. Hash comparison: `Get-FileHash src\\parser.c` vs `Get-FileHash grammars\\autohotkey\\src\\parser.c`",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.487Z"
          },
          {
            "id": 3,
            "title": "Clear Zed extension cache and reinstall",
            "description": "Perform a full cache clear and extension reinstall to eliminate caching as the cause of partial command highlighting",
            "dependencies": [
              2
            ],
            "details": "Delete the grammars/autohotkey directory entirely, uninstall the dev extension from Zed, clear Zed's extension cache (typically in AppData or similar), then reinstall the dev extension fresh. Zed may be caching an older version of the parser that only recognized MsgBox and Gui. After reinstall, test all commands (MsgBox, Sleep, Send, Run, etc.) for proper highlighting.",
            "status": "done",
            "testStrategy": "After cache clear and reinstall: open test.ahk with all commands, verify Sleep/Send/Run highlight as @function.builtin same as MsgBox",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.491Z"
          },
          {
            "id": 4,
            "title": "Test grammar in alternative tree-sitter editors",
            "description": "Test the grammar in Neovim or Helix to verify if the issue is Zed-specific or a tree-sitter grammar issue",
            "dependencies": [
              1
            ],
            "details": "Install tree-sitter-autohotkey in Neovim (using nvim-treesitter) or Helix editor. Both use tree-sitter for syntax highlighting. Create a test file with all command types and verify highlighting. If commands highlight correctly in other editors but not Zed, the issue is Zed-specific. This helps narrow down whether to focus on grammar changes or Zed extension configuration.",
            "status": "done",
            "testStrategy": "Open same test.ahk in Neovim/Helix with tree-sitter highlighting enabled. Document which commands highlight correctly vs incorrectly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.494Z"
          },
          {
            "id": 5,
            "title": "Investigate keyword extraction mechanism for command_name conflicts",
            "description": "Deep dive into how tree-sitter's keyword extraction interacts with command_name to understand why some commands work and others don't",
            "dependencies": [
              1,
              2
            ],
            "details": "The grammar uses `word: $ => $.identifier` for keyword extraction. When the lexer sees 'Sleep', it first returns sym_identifier, then ts_lex_keywords checks if it's a command_name. Investigate if there's a conflict between command_name entries and other rules. Check parser.c ts_lex_keywords function to see state transitions for each command. Test hypothesis: perhaps MsgBox/Gui work because they're alphabetically first or have special precedence handling. Try reordering commands in grammar.js to test if order matters.",
            "status": "done",
            "testStrategy": "Modify grammar.js to reorder commands (put Sleep first), regenerate parser, test if Sleep now works while MsgBox breaks. This tests the ordering hypothesis.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.498Z"
          }
        ],
        "updatedAt": "2025-12-26T15:04:03.498Z"
      },
      {
        "id": "15",
        "title": "Add built-in variables to grammar",
        "description": "Recognize AHK built-in variables (A_ScriptDir, A_Now, A_TickCount, etc.) with distinct highlighting.",
        "details": "Update `grammar.js`:\n\n```javascript\nbuiltin_variable: $ => token(seq(\n  'A_',\n  choice(\n    'ScriptDir', 'ScriptFullPath', 'ScriptName',\n    'WorkingDir', 'Desktop', 'MyDocuments', 'AppData',\n    'Now', 'NowUTC', 'TickCount', 'TimeIdle',\n    'Cursor', 'CaretX', 'CaretY',\n    'ScreenWidth', 'ScreenHeight',\n    'ThisHotkey', 'PriorHotkey', 'TimeSinceThisHotkey',\n    'LoopField', 'LoopFileName', 'LoopFileFullPath', 'Index',\n    'Clipboard', 'ErrorLevel', 'LastError',\n    // Add more as needed\n  )\n)),\n```\n\nUpdate `highlights.scm`:\n```scheme\n(builtin_variable) @variable.builtin\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   path := A_ScriptDir\n   time := A_Now\n   MsgBox, %A_TickCount%\n   ```\n3. Verify A_ variables highlight differently from regular variables",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T02:39:41.734Z"
      },
      {
        "id": "16",
        "title": "Add object/method syntax to grammar",
        "description": "Parse object property access (obj.property) and method calls (obj.method()) with appropriate highlighting.",
        "details": "Update `grammar.js`:\n\n```javascript\nmember_expression: $ => seq(\n  field('object', choice($.identifier, $.member_expression)),\n  '.',\n  field('property', $.identifier)\n),\n\nmethod_call: $ => seq(\n  field('object', choice($.identifier, $.member_expression)),\n  '.',\n  field('method', $.identifier),\n  token.immediate('('),\n  optional($.argument_list),\n  ')'\n),\n```\n\nAdd to `_expression` choice.\n\nUpdate `highlights.scm`:\n```scheme\n(member_expression property: (identifier) @property)\n(method_call method: (identifier) @function.method)\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   obj := {}\n   obj.name := \"test\"\n   obj.nested.value := 1\n   result := obj.GetValue()\n   ```\n3. Verify properties and methods highlight appropriately",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add member_expression rule to grammar.js",
            "description": "Define the member_expression rule in grammar.js to parse object property access syntax (obj.property, obj.nested.property).",
            "dependencies": [],
            "details": "Add member_expression rule to grammar.js:\n\n```javascript\nmember_expression: $ => prec.left(1, seq(\n  field('object', choice($.identifier, $.member_expression)),\n  '.',\n  field('property', $.identifier)\n)),\n```\n\nPlace this after function_call definition. Use prec.left to handle left-associative chaining (obj.a.b parses as (obj.a).b). The choice allows both simple identifiers and nested member expressions as the object.",
            "status": "done",
            "testStrategy": "Run `npm run generate` and verify parser compiles. Test with `npx tree-sitter parse` on a file containing `obj.property` and `obj.nested.value`.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.577Z"
          },
          {
            "id": 2,
            "title": "Add method_call rule to grammar.js",
            "description": "Define the method_call rule in grammar.js to parse method invocation syntax (obj.method(), obj.nested.method(args)).",
            "dependencies": [
              1
            ],
            "details": "Add method_call rule to grammar.js:\n\n```javascript\nmethod_call: $ => prec.left(2, seq(\n  field('object', choice($.identifier, $.member_expression)),\n  '.',\n  field('method', $.identifier),\n  token.immediate('('),\n  optional($.argument_list),\n  ')'\n)),\n```\n\nUse token.immediate('(') to prevent whitespace between method name and parenthesis (matching existing function_call pattern). Higher precedence (2) than member_expression (1) ensures `obj.method()` parses as method_call, not member_expression with trailing parens.",
            "status": "done",
            "testStrategy": "Run `npm run generate` and parse test file with `obj.Method()`, `obj.GetValue(arg1, arg2)`, and `obj.nested.Method()`.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.582Z"
          },
          {
            "id": 3,
            "title": "Integrate new rules into _expression and handle conflicts",
            "description": "Add member_expression and method_call to the _expression choice and update the conflicts array to resolve ambiguities.",
            "dependencies": [
              2
            ],
            "details": "Update _expression in grammar.js:\n\n```javascript\n_expression: $ => choice(\n  $.string,\n  $.number,\n  prec(3, $.builtin_variable),\n  $.member_expression,\n  $.method_call,\n  $.identifier,\n  $.function_call,\n),\n```\n\nAdd to conflicts array if needed:\n```javascript\nconflicts: $ => [\n  [$.parameter, $._expression],\n  [$.command],\n  [$.member_expression, $.method_call],\n],\n```\n\nOrder matters - place member_expression and method_call before identifier so they're tried first.",
            "status": "done",
            "testStrategy": "Run `npm run generate` - should complete without conflict errors. Parse mixed expressions like `result := obj.name` and `x := obj.GetValue()`.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.586Z"
          },
          {
            "id": 4,
            "title": "Add highlight queries for member expressions and method calls",
            "description": "Update highlights.scm with queries to highlight properties with @property and methods with @function.method.",
            "dependencies": [
              3
            ],
            "details": "Add to languages/autohotkey/highlights.scm:\n\n```scheme\n; Member expressions - property access\n(member_expression property: (identifier) @property)\n\n; Method calls\n(method_call method: (identifier) @function.method)\n(method_call object: (identifier) @variable)\n(method_call object: (member_expression))\n```\n\nThe property field gets @property highlight. The method field gets @function.method. Optionally highlight the object as @variable for clarity. Place after the function rules section.",
            "status": "done",
            "testStrategy": "Verify syntax by checking for typos. After push and Zed extension reload, confirm `obj.property` shows property in distinct color and `obj.Method()` highlights Method as a function.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.589Z"
          },
          {
            "id": 5,
            "title": "Test complete implementation and update extension.toml",
            "description": "Verify the full implementation with comprehensive test cases, commit changes, push to GitHub, and update extension.toml rev.",
            "dependencies": [
              4
            ],
            "details": "1. Create test file with comprehensive cases:\n```ahk\nobj := {}\nobj.name := \"test\"\nobj.nested.value := 1\nresult := obj.GetValue()\nobj.nested.Method(arg1, arg2)\nx := obj.a.b.c\ny := obj.First().Second()\n```\n\n2. Run `npm run generate` and `npm run test` (if tests exist)\n3. Parse test file: `npx tree-sitter parse test.ahk`\n4. Verify AST shows member_expression and method_call nodes with correct fields\n5. Commit and push: `git add . && git commit -m \"feat: Add object/method syntax\" && git push`\n6. Get new rev: `git rev-parse HEAD`\n7. Update extension.toml rev field\n8. Delete grammars/ folder and reinstall dev extension in Zed",
            "status": "done",
            "testStrategy": "Full integration test: After Zed extension reload, open an AHK file with object syntax. Verify: 1) No parse errors in tree-sitter output, 2) Properties highlight distinctly, 3) Methods highlight as functions, 4) Chained access works (obj.a.b.Method()).",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T15:04:03.592Z"
          }
        ],
        "updatedAt": "2025-12-26T15:04:03.592Z"
      },
      {
        "id": "17",
        "title": "Add array syntax to grammar",
        "description": "Parse array literals ([1, 2, 3]) and array access (arr[index]) with highlighting.",
        "details": "Update `grammar.js`:\n\n```javascript\narray_literal: $ => seq(\n  '[',\n  optional(seq(\n    $._expression,\n    repeat(seq(',', $._expression))\n  )),\n  ']'\n),\n\nindex_expression: $ => seq(\n  field('object', choice($.identifier, $.member_expression, $.index_expression)),\n  '[',\n  field('index', $._expression),\n  ']'\n),\n```\n\nAdd to `_expression` choice.\n\nUpdate `highlights.scm`:\n```scheme\n(array_literal \"[\" @punctuation.bracket)\n(array_literal \"]\" @punctuation.bracket)\n(index_expression \"[\" @punctuation.bracket)\n(index_expression \"]\" @punctuation.bracket)\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   arr := [1, 2, 3]\n   first := arr[1]\n   nested := arr[1][2]\n   ```\n3. Verify arrays parse correctly and brackets highlight",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T03:14:31.820Z"
      },
      {
        "id": "18",
        "title": "Add escape sequences in strings to grammar",
        "description": "Parse AHK escape sequences (`n, `t, `r, ``, etc.) within strings with distinct highlighting.",
        "details": "Update `grammar.js` string rule to capture escape sequences:\n\n```javascript\nstring: $ => choice(\n  seq('\"', repeat(choice($.escape_sequence, /[^\"``]+/)), '\"'),\n  seq(\"'\", repeat(choice($.escape_sequence, /[^'``]+/)), \"'\"),\n),\n\nescape_sequence: $ => token(seq(\n  '`',\n  choice(\n    'n',   // newline\n    't',   // tab\n    'r',   // carriage return\n    'b',   // backspace\n    'v',   // vertical tab\n    'a',   // bell\n    'f',   // form feed\n    '`',   // literal backtick\n    ';',   // literal semicolon\n    ':',   // literal colon\n    's',   // space\n    '\"',   // literal quote\n    \"'\",   // literal single quote\n  )\n)),\n```\n\nUpdate `highlights.scm`:\n```scheme\n(escape_sequence) @string.escape\n```",
        "testStrategy": "1. Run `npm run generate`\n2. Test with:\n   ```ahk\n   msg := \"Hello`nWorld\"\n   path := \"C:``temp``file.txt\"\n   tab := \"col1`tcol2\"\n   ```\n3. Verify escape sequences highlight within strings",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T04:29:20.046Z"
      },
      {
        "id": "19",
        "title": "Add outline.scm for document symbols",
        "description": "Create outline.scm to enable document outline panel and go-to-symbol (Cmd+Shift+O) for functions, labels, hotkeys, and classes.",
        "details": "Create `languages/autohotkey/outline.scm`:\n\n```scheme\n(function_definition\n  name: (identifier) @name) @item\n\n(label\n  name: (identifier) @name) @item\n\n(hotkey) @name @item\n\n(directive) @name @item\n```\n\nThis enables:\n- Outline panel showing all functions, labels, hotkeys\n- Go-to-symbol navigation (Cmd+Shift+O / Ctrl+Shift+O)\n- Breadcrumbs in the editor",
        "testStrategy": "1. Create outline.scm\n2. Commit, push, update rev, clear cache, reinstall\n3. Open test.ahk and press Cmd+Shift+O\n4. Verify functions and labels appear in symbol list",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T05:34:30.171Z"
      },
      {
        "id": "20",
        "title": "Add indents.scm for auto-indentation",
        "description": "Create indents.scm to enable automatic indentation after opening braces, if/else, loops, etc.",
        "details": "Create `languages/autohotkey/indents.scm`:\n\n```scheme\n; Indent after opening brace\n\"{\" @indent\n\"}\" @outdent\n\n; Indent after control structures\n(function_definition) @indent\n```\n\nThis enables:\n- Auto-indent when pressing Enter after `{`\n- Auto-outdent when typing `}`\n- Proper indentation in function bodies",
        "testStrategy": "1. Create indents.scm\n2. Commit, push, update rev, clear cache, reinstall\n3. Type `MyFunc() {` and press Enter\n4. Verify cursor is indented\n5. Type `}` and verify it outdents",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T05:46:36.275Z"
      },
      {
        "id": "21",
        "title": "Add textobjects.scm for vim motions",
        "description": "Create textobjects.scm to enable vim text objects like `vaf` (select around function), `vif` (select inside function), and `]m` (next function).",
        "details": "Create `languages/autohotkey/textobjects.scm`:\n\n```scheme\n; Function text object\n(function_definition) @function.around\n(function_definition\n  body: (_) @function.inside)\n\n; Class text object (if we add class support)\n; (class_definition) @class.around\n```\n\nThis enables:\n- `vaf` - select around function\n- `vif` - select inside function\n- `daf` - delete around function\n- `]m` / `[m` - jump to next/previous function",
        "testStrategy": "1. Create textobjects.scm\n2. Commit, push, update rev, clear cache, reinstall\n3. Place cursor inside a function\n4. Press `vaf` in vim mode\n5. Verify entire function is selected",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T06:03:57.116Z"
      },
      {
        "id": "22",
        "title": "Add runnables.scm for running AHK scripts",
        "description": "Create runnables.scm to add a 'Run' button in the gutter for executing AutoHotkey scripts directly from Zed.",
        "details": "Create `languages/autohotkey/runnables.scm`:\n\n```scheme\n; Add run button at start of file\n(source_file . (_) @run)\n```\n\nAlso need to document task configuration in README:\n```json\n// .zed/tasks.json\n{\n  \"label\": \"Run AHK Script\",\n  \"command\": \"AutoHotkey.exe\",\n  \"args\": [\"$ZED_FILE\"]\n}\n```\n\nRequires AutoHotkey to be installed and in PATH.",
        "testStrategy": "1. Create runnables.scm\n2. Commit, push, update rev, clear cache, reinstall\n3. Open an .ahk file\n4. Look for run button in gutter\n5. Configure task and test running script",
        "priority": "low",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T22:50:36.020Z"
      },
      {
        "id": "10",
        "title": "Add tree-sitter test suite and finalize grammar",
        "description": "Create proper tree-sitter test cases to validate grammar correctness and ensure future modifications don't break parsing.",
        "details": "Create `test/corpus/` directory with test files:\n\n1. `test/corpus/comments.txt`:\n```\n==================\nLine comment\n==================\n; This is a comment\n---\n(source_file\n  (comment))\n\n==================\nBlock comment\n==================\n/* Multi\nline */\n---\n(source_file\n  (block_comment))\n```\n\n2. `test/corpus/literals.txt`:\n```\n==================\nString literals\n==================\n\"double quoted\"\n'single quoted'\n---\n(source_file\n  (string)\n  (string))\n\n==================\nNumbers\n==================\n123\n0xFF\n3.14\n---\n(source_file\n  (number)\n  (number)\n  (number))\n```\n\n3. `test/corpus/functions.txt`:\n```\n==================\nFunction definition\n==================\nMyFunc() {\n}\n---\n(source_file\n  (function_definition\n    name: (identifier)))\n```\n\nRun tests with `npm test` or `npx tree-sitter test`.",
        "testStrategy": "1. Run `npx tree-sitter test` - all tests should pass\n2. Add edge cases: empty files, nested comments, special characters\n3. Document any known limitations in README.md\n4. Verify grammar still works in Zed after all changes",
        "priority": "medium",
        "dependencies": [
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T15:04:03.678Z"
      },
      {
        "id": "11",
        "title": "Fix Windows dev extension installation for Zed",
        "description": "Troubleshoot and resolve the Zed dev extension installation issue on Windows, ensuring the AutoHotkey extension can be successfully installed and recognized by Zed.",
        "status": "done",
        "dependencies": [
          "6"
        ],
        "priority": "high",
        "details": "## Root Cause Identified\n\nThe error **\"Failed to install dev extension: failed to compile grammar 'autohotkey'\"** occurs because `extension.toml` is missing the `[grammars.autohotkey]` section that tells Zed where to find the grammar source.\n\n## Current State\n\n**Files that exist and are correct:**\n- `grammar.js` - Tree-sitter grammar with comment parsing\n- `src/parser.c` - Generated parser (from `npm run generate`)\n- `grammars/autohotkey.wasm` - Pre-built WASM (2776 bytes)\n- `languages/autohotkey/config.toml` - Language configuration\n- `languages/autohotkey/highlights.scm` - Syntax highlighting queries\n\n**The problem:** `extension.toml` lacks grammar source configuration:\n```toml\n# Current (BROKEN)\nid = \"autohotkey\"\nname = \"AutoHotkey\"\nversion = \"0.1.0\"\nschema_version = 1\nauthors = [\"Alfredo\"]\ndescription = \"AutoHotkey v1 language support for Zed\"\nrepository = \"https://github.com/Alfredo/tree-sitter-autohotkey\"\n# MISSING: [grammars.autohotkey] section!\n```\n\n## Fix Required\n\nAdd the `[grammars.autohotkey]` section to `extension.toml`:\n```toml\nid = \"autohotkey\"\nname = \"AutoHotkey\"\nversion = \"0.1.0\"\nschema_version = 1\nauthors = [\"Alfredo\"]\ndescription = \"AutoHotkey v1 language support for Zed\"\nrepository = \"https://github.com/Alfredo/tree-sitter-autohotkey\"\n\n[grammars.autohotkey]\nrepository = \"https://github.com/Alfredo/tree-sitter-autohotkey\"\npath = \".\"\n```\n\n**Note:** For local dev extensions, Zed uses the `path` field. The `repository` field is for published extensions but including it doesn't hurt.\n\n## After Fixing extension.toml\n\n1. **Reinstall dev extension in Zed:**\n   - Open Command Palette (`Ctrl+Shift+P`)\n   - Run \"Extensions: Install Dev Extension\"\n   - Select `C:\\Users\\Alfredo\\Documents\\GitHub\\tree-sitter-autohotkey`\n\n2. **Verify installation:**\n   - Open `test.ahk` file\n   - Status bar should show \"AutoHotkey\"\n   - Comments (`;` and `/* */`) should be syntax highlighted\n\n## Directory Structure Reference\n\n```\ntree-sitter-autohotkey/\n├── extension.toml           # Extension manifest (NEEDS [grammars] section)\n├── grammar.js               # Tree-sitter grammar source\n├── package.json             # Node.js project config\n├── src/\n│   ├── parser.c             # Generated parser\n│   ├── grammar.json         # Generated grammar JSON\n│   └── tree_sitter/\n│       └── parser.h\n├── grammars/\n│   └── autohotkey.wasm      # Pre-built WASM grammar (2776 bytes)\n└── languages/\n    └── autohotkey/\n        ├── config.toml      # Language config (line_comments, etc.)\n        └── highlights.scm   # Highlight queries\n```",
        "testStrategy": "1. **Apply the fix:**\n   - Edit `extension.toml` to add the `[grammars.autohotkey]` section\n\n2. **Test installation:**\n   - Open Zed\n   - Run \"Extensions: Install Dev Extension\" from Command Palette\n   - Select the `tree-sitter-autohotkey` directory\n   - Verify NO error popup appears\n\n3. **Verify functionality:**\n   - Open `test.ahk` (contains: `; This is a comment`, block comment, and code)\n   - Status bar should show \"AutoHotkey\" as the language\n   - Line comment (`;`) should be highlighted in comment color\n   - Block comment (`/* */`) should be highlighted in comment color\n   - Non-comment text should NOT be comment-colored\n\n4. **Test comment toggling:**\n   - Place cursor on a line\n   - Press `Ctrl+/` to toggle line comment\n   - Should add/remove `;` prefix\n\n5. **If issues persist:**\n   - Run `zed --foreground` to see logs\n   - Check `%LOCALAPPDATA%\\Zed\\logs\\Zed.log` for detailed errors",
        "subtasks": [
          {
            "id": 1,
            "title": "Add [grammars.autohotkey] section to extension.toml",
            "description": "Fix the root cause by adding the missing grammar configuration section to extension.toml",
            "dependencies": [],
            "details": "Edit `extension.toml` to add:\n```toml\n[grammars.autohotkey]\nrepository = \"https://github.com/Alfredo/tree-sitter-autohotkey\"\npath = \".\"\n```\n\nThis tells Zed where to find the grammar source files (`grammar.js` and generated `src/` files) when compiling the extension.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-25T21:08:36.958Z"
          },
          {
            "id": 2,
            "title": "Reinstall dev extension in Zed",
            "description": "After fixing extension.toml, reinstall the dev extension to verify the fix works",
            "dependencies": [
              1
            ],
            "details": "1. Open Zed\n2. Press `Ctrl+Shift+P` to open Command Palette\n3. Run \"Extensions: Install Dev Extension\"\n4. Navigate to `C:\\Users\\Alfredo\\Documents\\GitHub\\tree-sitter-autohotkey`\n5. Select the folder\n6. Verify no error popup appears (previously showed: \"Failed to install dev extension: failed to compile grammar 'autohotkey'\")",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-25T21:08:45.022Z"
          },
          {
            "id": 3,
            "title": "Verify syntax highlighting works on test.ahk",
            "description": "Confirm the extension is working by checking syntax highlighting on the test file",
            "dependencies": [
              2
            ],
            "details": "1. Open `test.ahk` which contains:\n   - Line comment: `; This is a comment`\n   - Block comment: `/* Block\\ncomment */`\n   - Plain code: `some code here`\n2. Verify status bar shows \"AutoHotkey\"\n3. Verify comments are highlighted differently from code\n4. Test `Ctrl+/` toggles line comment",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-25T21:08:53.075Z"
          }
        ],
        "updatedAt": "2025-12-25T21:08:53.075Z"
      },
      {
        "id": "23",
        "title": "Add class definition syntax to grammar",
        "description": "Parse AHK v1 class definitions including class declarations, constructors (__New), methods, properties with initializers, inheritance (extends), and the 'this' keyword with proper syntax highlighting.",
        "details": "Update `grammar.js` to add class definition rules:\n\n```javascript\n// Add class_definition rule (similar precedence to function_definition)\nclass_definition: $ => prec(2, seq(\n  'class',\n  field('name', $.identifier),\n  optional(seq('extends', field('superclass', $.identifier))),\n  '{',\n  repeat($._class_body_item),\n  '}'\n)),\n\n// Class body can contain methods, properties, and nested classes\n_class_body_item: $ => choice(\n  $.class_method,\n  $.class_property,\n  $.class_definition,  // Nested classes\n  $.comment,\n  $.doc_comment,\n  $.block_comment,\n),\n\n// Class methods (including __New constructor, __Delete destructor, __Get/__Set/__Call meta-functions)\nclass_method: $ => prec(2, seq(\n  optional('static'),\n  field('name', $.identifier),\n  token.immediate('('),\n  optional($.parameter_list),\n  ')',\n  '{',\n  repeat($._statement),\n  '}'\n)),\n\n// Class properties with optional initializers\nclass_property: $ => seq(\n  optional('static'),\n  field('name', $.identifier),\n  optional(seq(':=', $._expression))\n),\n\n// Add 'this' as a special identifier (high precedence like builtin_variable)\nthis_expression: $ => token(prec(3, 'this')),\n```\n\nAdd to `_statement` choice:\n```javascript\n_statement: $ => choice(\n  // ... existing choices ...\n  $.class_definition,\n  $.this_expression,\n  // ...\n),\n```\n\nAdd `this_expression` to `_expression` choice:\n```javascript\n_expression: $ => choice(\n  // ... existing choices ...\n  $.this_expression,\n  // ...\n),\n```\n\nUpdate `highlights.scm`:\n```scheme\n; Class definitions\n(class_definition . (identifier) @type)\n(class_definition superclass: (identifier) @type)\n\n; Class methods\n(class_method name: (identifier) @function.method)\n\n; Class properties\n(class_property name: (identifier) @property)\n\n; Constructor and special methods\n((class_method name: (identifier) @constructor)\n (#match? @constructor \"^__New$\"))\n\n; Destructor\n((class_method name: (identifier) @function.special)\n (#match? @function.special \"^__Delete$\"))\n\n; Meta-functions\n((class_method name: (identifier) @function.special)\n (#match? @function.special \"^__(Get|Set|Call)$\"))\n\n; 'this' keyword\n(this_expression) @variable.builtin\n\n; Static keyword in class context\n(class_method \"static\" @keyword)\n(class_property \"static\" @keyword)\n```\n\nKey implementation considerations:\n1. The 'class' and 'extends' keywords already exist in the keyword rule - they'll need special handling so they parse as part of class_definition rather than standalone keywords\n2. Consider using `prec()` to ensure class_definition takes precedence over other statement types when 'class' is encountered\n3. The `__New` constructor is just a method with a special name - use highlight queries with `#match?` predicate to style it differently\n4. Properties without initializers are valid: `class Foo { bar }` should parse `bar` as a class_property\n5. 'this' should be recognized in expressions: `this.value`, `this.Method()`, `return this`",
        "testStrategy": "1. Run `npm run generate` - should complete without errors\n\n2. Create `test/corpus/classes.txt` with test cases:\n```\n================================================================================\nSimple class definition\n================================================================================\n\nclass MyClass {\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (class_definition\n    name: (identifier)))\n\n================================================================================\nClass with constructor\n================================================================================\n\nclass MyClass {\n  __New() {\n  }\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (class_definition\n    name: (identifier)\n    (class_method\n      name: (identifier))))\n\n================================================================================\nClass with inheritance\n================================================================================\n\nclass Child extends Parent {\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (class_definition\n    name: (identifier)\n    superclass: (identifier)))\n\n================================================================================\nClass with property\n================================================================================\n\nclass MyClass {\n  value := 10\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (class_definition\n    name: (identifier)\n    (class_property\n      name: (identifier)\n      (number))))\n\n================================================================================\nClass with static method\n================================================================================\n\nclass MyClass {\n  static GetInstance() {\n  }\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (class_definition\n    name: (identifier)\n    (class_method\n      name: (identifier))))\n\n================================================================================\nThis expression\n================================================================================\n\nthis.value\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (member_expression\n    object: (this_expression)\n    property: (identifier)))\n```\n\n3. Run `npm run test` - all tests should pass\n\n4. Create test file `test-classes.ahk`:\n```ahk\nclass Animal {\n    name := \"\"\n    \n    __New(name) {\n        this.name := name\n    }\n    \n    Speak() {\n        MsgBox, %this.name% says hello\n    }\n}\n\nclass Dog extends Animal {\n    static count := 0\n    \n    __New(name) {\n        base.__New(name)\n        Dog.count += 1\n    }\n    \n    Speak() {\n        MsgBox, %this.name% barks\n    }\n}\n```\n\n5. Run `npm run parse test-classes.ahk` - verify AST shows correct class structure\n\n6. Verify syntax highlighting in Zed:\n   - Class names should highlight as @type\n   - `this` should highlight as @variable.builtin\n   - `__New` should highlight as @constructor\n   - Regular methods should highlight as @function.method\n   - Properties should highlight as @property\n   - `static`, `class`, `extends` should highlight as @keyword",
        "status": "done",
        "dependencies": [
          "2",
          "5",
          "7",
          "8",
          "16"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:40:23.824Z"
      },
      {
        "id": "24",
        "title": "Add hotstring syntax to grammar",
        "description": "Parse AHK v1 hotstrings like `::btw::by the way` and `:*:btw::by the way` with support for trigger text, options (*, ?, C, etc.), and replacement text.",
        "details": "Update `grammar.js` to add hotstring parsing:\n\n```javascript\n// Add to _statement choice (after hotkey for similar grouping):\n$.hotstring_definition,\n\n// Hotstring definition: :options:trigger::replacement\nhotstring_definition: $ => seq(\n  ':',\n  optional(field('options', $.hotstring_options)),\n  ':',\n  field('trigger', $.hotstring_trigger),\n  '::',\n  optional(field('replacement', $.hotstring_replacement))\n),\n\n// Options between first colons: *, ?, C, C1, O, R, SI, SE, SP, T, X, Z, B0, etc.\nhotstring_options: $ => token(/[*?CORZTXB0-9SIEP]+/i),\n\n// Trigger text: the abbreviation to expand (until ::)\nhotstring_trigger: $ => token(/[^:\\n]+/),\n\n// Replacement text: everything after :: until end of line\nhotstring_replacement: $ => token(/[^\\n]+/),\n```\n\n**Key design decisions:**\n1. Use `token()` for trigger and replacement to capture as single nodes without splitting on spaces\n2. Options are case-insensitive (both `C` and `c` work in AHK)\n3. Replacement is optional - some hotstrings use `X` option to execute code instead\n4. The `::` separator between trigger and replacement is a distinct token for reliable parsing\n\n**Grammar ordering:**\n- Place `hotstring_definition` before `hotkey` in `_statement` choice since both start with `:` patterns\n- The hotstring pattern (`:...:..::`) is more specific than hotkey (`...::`)\n\nUpdate `languages/autohotkey/highlights.scm`:\n```scheme\n; Hotstrings\n(hotstring_definition \":\" @punctuation.delimiter)\n(hotstring_trigger) @string.special\n(hotstring_options) @attribute\n(hotstring_replacement) @string\n```\n\n**Note:** Use `@string.special` for trigger (as specified) since it's a special kind of string literal - the abbreviation being defined. The replacement uses regular `@string` since it's the literal text that will be typed.",
        "testStrategy": "1. Run `npm run generate` - verify no grammar errors\n\n2. Create test file `test/corpus/hotstrings.txt`:\n```\n================================================================================\nSimple hotstring\n================================================================================\n\n::btw::by the way\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (hotstring_definition\n    (hotstring_trigger)\n    (hotstring_replacement)))\n\n================================================================================\nHotstring with immediate option\n================================================================================\n\n:*:btw::by the way\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (hotstring_definition\n    (hotstring_options)\n    (hotstring_trigger)\n    (hotstring_replacement)))\n\n================================================================================\nHotstring with case-sensitive option\n================================================================================\n\n:C:BTW::BY THE WAY\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (hotstring_definition\n    (hotstring_options)\n    (hotstring_trigger)\n    (hotstring_replacement)))\n\n================================================================================\nHotstring with multiple options\n================================================================================\n\n:*?C:btw::by the way\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (hotstring_definition\n    (hotstring_options)\n    (hotstring_trigger)\n    (hotstring_replacement)))\n\n================================================================================\nHotstring without replacement (X option)\n================================================================================\n\n:X:btw::\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (hotstring_definition\n    (hotstring_options)\n    (hotstring_trigger)))\n```\n\n3. Run `npm run test` - all hotstring tests should pass\n\n4. Create manual test file:\n```ahk\n; Basic hotstrings\n::btw::by the way\n::omw::on my way\n::sig::Best regards,`nJohn\n\n; With options\n:*:btw::by the way     ; immediate\n:?:ing::ING            ; inside words\n:C:BTW::BY THE WAY     ; case-sensitive\n:*?C:btw::by the way   ; multiple options\n:B0:btw::by the way    ; no backspacing\n\n; Execute code instead of replacement\n:X:now::\n```\n\n5. Run `npm run parse test.ahk` - verify AST shows correct node structure\n\n6. Push to GitHub, update `rev` in extension.toml, delete `grammars/` folder, reinstall dev extension in Zed\n\n7. Verify in Zed:\n   - Trigger text (`btw`) highlights as `@string.special`\n   - Options (`*`, `C`, `?`) highlight as `@attribute`\n   - Replacement text (`by the way`) highlights as regular string\n   - Colons (`:` and `::`) highlight as punctuation",
        "status": "done",
        "dependencies": [
          "9"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:40:25.856Z"
      },
      {
        "id": "25",
        "title": "Add control flow block structures to grammar",
        "description": "Parse if/else/while/loop/for statements with proper body blocks, enabling structured syntax trees that support proper indentation and text objects in editors.",
        "details": "Update `grammar.js` to add control flow statement rules that parse keywords with their conditions and body blocks. Currently keywords like `if`, `while`, `loop`, `for` are recognized but their bodies are not structured.\n\n**New Grammar Rules:**\n\n```javascript\n// Add to _statement choice (order matters - before $.keyword):\n$.if_statement,\n$.while_statement,\n$.loop_statement,\n$.for_statement,\n\n// If statement with optional else clause\nif_statement: $ => seq(\n  'if',\n  field('condition', $.parenthesized_expression),\n  field('body', $.block),\n  optional(field('alternative', $.else_clause))\n),\n\nelse_clause: $ => seq(\n  'else',\n  choice(\n    field('body', $.block),\n    field('if', $.if_statement)  // else if chains\n  )\n),\n\n// While statement\nwhile_statement: $ => seq(\n  'while',\n  field('condition', $.parenthesized_expression),\n  field('body', $.block)\n),\n\n// Loop statement - supports multiple AHK v1 variants\n// Loop, Loop N, Loop Parse, Loop Read, Loop Files\nloop_statement: $ => seq(\n  'loop',\n  optional(choice(\n    field('count', $._expression),\n    seq(\n      choice('parse', 'read', 'files', 'reg'),\n      optional($.loop_parameters)\n    )\n  )),\n  field('body', $.block)\n),\n\nloop_parameters: $ => seq(\n  ',',\n  repeat1(choice(\n    $.variable_ref,\n    $.string,\n    $.identifier,\n    ',',\n  ))\n),\n\n// For statement (for k, v in obj)\nfor_statement: $ => seq(\n  'for',\n  field('key', $.identifier),\n  optional(seq(',', field('value', $.identifier))),\n  'in',\n  field('object', $._expression),\n  field('body', $.block)\n),\n\n// Parenthesized expression for conditions\nparenthesized_expression: $ => seq(\n  '(',\n  $._expression,\n  ')'\n),\n\n// Block - reuse existing brace matching, but named\nblock: $ => seq(\n  '{',\n  repeat($._statement),\n  '}'\n),\n```\n\n**Key Implementation Notes:**\n\n1. **Remove overlapping keyword matches**: Update the `keyword` rule to remove `if`, `else`, `while`, `loop`, `for` since they now have dedicated statement rules\n\n2. **Precedence considerations**: Use `prec()` appropriately to ensure control flow statements match before falling back to generic keyword parsing\n\n3. **Handle OTB (One True Brace) style**: AHK v1 allows brace on same line or next line. The grammar should handle both:\n   ```ahk\n   if (x) {    ; OTB style\n       y := 1\n   }\n   \n   if (x)      ; Traditional style\n   {\n       y := 1\n   }\n   ```\n\n4. **Loop variants to support**:\n   - `Loop` - infinite loop\n   - `Loop, N` - count-based loop\n   - `Loop, Parse, InputVar, Delimiters` - parse loop\n   - `Loop, Read, InputFile` - file read loop\n   - `Loop, Files, FilePattern` - file loop\n   - `Loop, Reg, RootKey, Key` - registry loop\n\n5. **Conflicts array**: May need to add new conflicts if ambiguities arise between control flow statements and other rules\n\n6. **Update highlights.scm** to highlight control flow keywords and blocks:\n   ```scheme\n   (if_statement \"if\" @keyword.control)\n   (else_clause \"else\" @keyword.control)\n   (while_statement \"while\" @keyword.control)\n   (loop_statement \"loop\" @keyword.control)\n   (for_statement \"for\" @keyword.control)\n   (for_statement \"in\" @keyword.control)\n   (block \"{\" @punctuation.bracket)\n   (block \"}\" @punctuation.bracket)\n   ```\n\n7. **Add to _statement in correct order**: Place control flow statements before `$.keyword` in the choice to ensure they take precedence",
        "testStrategy": "1. Run `npm run generate` - should complete without errors\n\n2. Create test/corpus/control_flow.txt with test cases:\n   ```\n   ================================================================================\n   If statement with block\n   ================================================================================\n   \n   if (x == 1) {\n       y := 2\n   }\n   \n   --------------------------------------------------------------------------------\n   \n   (source_file\n     (if_statement\n       condition: (parenthesized_expression (identifier) (operator) (number))\n       body: (block (identifier) (operator) (number))))\n   \n   ================================================================================\n   If-else statement\n   ================================================================================\n   \n   if (x) {\n       a := 1\n   } else {\n       b := 2\n   }\n   \n   --------------------------------------------------------------------------------\n   \n   (source_file\n     (if_statement\n       condition: (parenthesized_expression (identifier))\n       body: (block ...)\n       alternative: (else_clause body: (block ...))))\n   \n   ================================================================================\n   While statement\n   ================================================================================\n   \n   while (running) {\n       DoWork()\n   }\n   \n   --------------------------------------------------------------------------------\n   \n   (source_file\n     (while_statement\n       condition: (parenthesized_expression (identifier))\n       body: (block (function_call ...))))\n   \n   ================================================================================\n   Simple loop\n   ================================================================================\n   \n   loop 10 {\n       count += 1\n   }\n   \n   --------------------------------------------------------------------------------\n   \n   (source_file\n     (loop_statement\n       count: (number)\n       body: (block ...)))\n   \n   ================================================================================\n   For-in statement\n   ================================================================================\n   \n   for key, value in myObject {\n       result .= key\n   }\n   \n   --------------------------------------------------------------------------------\n   \n   (source_file\n     (for_statement\n       key: (identifier)\n       value: (identifier)\n       object: (identifier)\n       body: (block ...)))\n   ```\n\n3. Run `npm run test` - all tests should pass including new control flow tests\n\n4. Test with test.ahk file containing nested control structures:\n   ```ahk\n   if (a > 0) {\n       while (b < 10) {\n           loop 5 {\n               for k, v in arr {\n                   Process(k, v)\n               }\n           }\n           b += 1\n       }\n   } else if (a < 0) {\n       return false\n   } else {\n       return true\n   }\n   ```\n\n5. Run `npx tree-sitter parse test.ahk` - verify:\n   - `if_statement` nodes contain proper condition and body fields\n   - `else_clause` nodes are children of if_statement\n   - Nested blocks are properly structured\n   - Loop variants parse correctly with their parameters\n\n6. Test highlighting in Zed:\n   - Push changes to GitHub\n   - Update `rev` in extension.toml\n   - Delete grammars/ folder\n   - Reinstall dev extension\n   - Verify control flow keywords highlight as @keyword.control\n   - Verify block braces highlight as @punctuation.bracket\n\n7. Verify text objects work in Zed (if configured): selecting `if` should allow expanding selection to include entire if_statement including body block",
        "status": "done",
        "dependencies": [
          "8",
          "9"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T14:54:35.736Z"
      },
      {
        "id": "26",
        "title": "Add try/catch/finally block structures to grammar",
        "description": "Parse error handling with try_statement containing try block, optional catch clause with exception variable binding, and optional finally clause. Example: try { risky() } catch e { handle(e) } finally { cleanup() }",
        "details": "Update `grammar.js` to add try_statement rule with proper structure:\n\n```javascript\n// Add to _statement choice (high priority so it takes precedence over loose keywords)\ntry_statement: $ => prec(5, seq(\n  'try',\n  $.block,\n  optional($.catch_clause),\n  optional($.finally_clause)\n)),\n\ncatch_clause: $ => seq(\n  'catch',\n  optional(field('exception', $.identifier)),  // Exception variable binding (optional in AHK v1)\n  $.block\n),\n\nfinally_clause: $ => seq(\n  'finally',\n  $.block\n),\n\n// Reusable block rule (also useful for future control flow structures)\nblock: $ => seq(\n  '{',\n  repeat($._statement),\n  '}'\n),\n```\n\n**Important implementation considerations:**\n\n1. **Precedence**: Use `prec(5, ...)` for `try_statement` to ensure it takes precedence over the standalone `keyword` matches for `try`, `catch`, and `finally`. Without this, the parser may match them as loose keywords.\n\n2. **Remove from keyword rule**: Keep `try`, `catch`, `finally`, `throw` in the keyword rule for standalone occurrences, but `try_statement` with higher precedence will match complete blocks.\n\n3. **Block reuse**: The `block` rule should be designed for reuse with future control flow (if/while/for statements).\n\n4. **Exception variable**: In AHK v1, the catch clause can optionally bind the exception: `catch e` or just `catch`. Make the identifier optional with `optional(field('exception', $.identifier))`.\n\n5. **Conflict resolution**: May need to add `[$.try_statement, $.keyword]` to the conflicts array if ambiguity arises between standalone keywords and structured statements.\n\n**Update `highlights.scm`:**\n\n```scheme\n; Try/catch/finally blocks\n(try_statement \"try\" @keyword)\n(catch_clause \"catch\" @keyword)\n(catch_clause exception: (identifier) @variable.parameter)\n(finally_clause \"finally\" @keyword)\n\n; Block braces\n(block \"{\" @punctuation.bracket)\n(block \"}\" @punctuation.bracket)\n```\n\n**Update `_statement` choice** to include `try_statement` before `keyword`:\n```javascript\n_statement: $ => choice(\n  $.comment,\n  $.doc_comment,\n  $.block_comment,\n  $.directive,\n  $.hotkey,\n  $.label,\n  $.function_definition,\n  $.try_statement,  // Add here, before keyword\n  // ... rest of choices\n  $.keyword,\n  // ...\n),\n```",
        "testStrategy": "1. Run `npm run generate` - should complete without errors\n\n2. Create test file `test/corpus/try_catch.txt`:\n```\n================================================================================\nSimple try block\n================================================================================\n\ntry {\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (try_statement\n    (block)))\n\n================================================================================\nTry with catch\n================================================================================\n\ntry {\n  risky()\n} catch e {\n  handle(e)\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (try_statement\n    (block\n      (function_call\n        name: (identifier)))\n    (catch_clause\n      exception: (identifier)\n      (block\n        (function_call\n          name: (identifier)\n          (argument_list\n            (identifier)))))))\n\n================================================================================\nTry with finally\n================================================================================\n\ntry {\n  risky()\n} finally {\n  cleanup()\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (try_statement\n    (block\n      (function_call\n        name: (identifier)))\n    (finally_clause\n      (block\n        (function_call\n          name: (identifier))))))\n\n================================================================================\nTry with catch and finally\n================================================================================\n\ntry {\n  risky()\n} catch e {\n  handle(e)\n} finally {\n  cleanup()\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (try_statement\n    (block\n      (function_call\n        name: (identifier)))\n    (catch_clause\n      exception: (identifier)\n      (block\n        (function_call\n          name: (identifier)\n          (argument_list\n            (identifier)))))\n    (finally_clause\n      (block\n        (function_call\n          name: (identifier))))))\n\n================================================================================\nCatch without exception variable\n================================================================================\n\ntry {\n  x := 1\n} catch {\n  MsgBox, Error\n}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (try_statement\n    (block\n      (identifier)\n      (operator)\n      (number))\n    (catch_clause\n      (block\n        (command\n          name: (command_name)\n          (command_arguments))))))\n```\n\n3. Run `npm run test` - all try/catch tests should pass\n\n4. Verify in Zed:\n   - `try`, `catch`, `finally` keywords highlight as `@keyword`\n   - Exception variable `e` highlights as `@variable.parameter`\n   - Block braces highlight as `@punctuation.bracket`\n\n5. Test edge cases:\n   - Nested try/catch blocks\n   - Try block inside function definition\n   - Standalone `try` keyword still works when not followed by block",
        "status": "done",
        "dependencies": [
          "8",
          "9"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:39:30.978Z"
      },
      {
        "id": "27",
        "title": "Add object literal syntax to grammar",
        "description": "Parse AHK object literals `{ key: value, key2: value2 }` as distinct from function/block bodies. Implement `object_literal` rule with key-value pairs supporting identifier or string keys, expression values, and shorthand `{ key }` syntax.",
        "details": "Update `grammar.js` to add object literal rules:\n\n```javascript\n// Add to _statement and _expression choices\nobject_literal: $ => prec(2, seq(\n  '{',\n  optional(seq(\n    $.object_property,\n    repeat(seq(',', $.object_property))\n  )),\n  '}'\n)),\n\nobject_property: $ => choice(\n  // Full syntax: key: value\n  seq(\n    field('key', choice($.identifier, $.string)),\n    ':',\n    field('value', $._expression)\n  ),\n  // Shorthand syntax: { key } equivalent to { key: key }\n  field('key', $.identifier)\n),\n```\n\n**Key implementation considerations:**\n\n1. **Disambiguation from function blocks**: Use `prec(2, ...)` to give object literals higher precedence. Function definitions already use `prec.dynamic(10, ...)` and require `name(params) {`, so the opening `{` alone should disambiguate correctly.\n\n2. **Colon conflict with labels**: Labels use `identifier:` at statement level. Object properties use `key: value` inside braces. The structural context (inside `{...}`) prevents ambiguity.\n\n3. **Add to `_expression` choice**: Object literals should be valid expressions:\n```javascript\n_expression: $ => choice(\n  $.string,\n  $.number,\n  prec(3, $.builtin_variable),\n  $.array_literal,\n  $.object_literal,  // Add here\n  $.index_expression,\n  $.member_expression,\n  $.method_call,\n  $.identifier,\n  $.function_call,\n),\n```\n\n4. **Add to `_statement` choice** (for standalone object literals):\n```javascript\n_statement: $ => choice(\n  // ... existing choices ...\n  $.object_literal,\n  // ... rest ...\n),\n```\n\n5. **Update `_punctuation` rule**: Remove `{` and `}` from the catch-all since they now have semantic meaning in object literals:\n```javascript\n_punctuation: $ => /[.,@$\\\\]+/,\n```\n\n**Update `highlights.scm`**:\n```scheme\n; Object literals\n(object_literal \"{\" @punctuation.bracket)\n(object_literal \"}\" @punctuation.bracket)\n(object_property key: (identifier) @property)\n(object_property key: (string) @property)\n(object_property \":\" @punctuation.delimiter)\n```\n\n**Conflict handling**: May need to add conflict resolution if the parser has trouble distinguishing `{ identifier }` (shorthand object) from a block containing just an identifier:\n```javascript\nconflicts: $ => [\n  [$.parameter, $._expression],\n  [$.command],\n  [$.object_property],  // May be needed for shorthand syntax\n],\n```",
        "testStrategy": "1. Run `npm run generate` - verify no grammar conflicts\n\n2. Create test file `test/corpus/objects.txt`:\n```\n================================================================================\nEmpty object literal\n================================================================================\n\nobj := {}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal))\n\n================================================================================\nObject with single property\n================================================================================\n\nobj := {name: \"test\"}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal\n    (object_property\n      key: (identifier)\n      value: (string))))\n\n================================================================================\nObject with multiple properties\n================================================================================\n\nobj := {name: \"test\", value: 42}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal\n    (object_property\n      key: (identifier)\n      value: (string))\n    (object_property\n      key: (identifier)\n      value: (number))))\n\n================================================================================\nObject with string keys\n================================================================================\n\nobj := {\"my-key\": 1, \"another\": 2}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal\n    (object_property\n      key: (string)\n      value: (number))\n    (object_property\n      key: (string)\n      value: (number))))\n\n================================================================================\nObject with shorthand property\n================================================================================\n\nobj := {name}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal\n    (object_property\n      key: (identifier))))\n\n================================================================================\nNested object literal\n================================================================================\n\nobj := {outer: {inner: 1}}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal\n    (object_property\n      key: (identifier)\n      value: (object_literal\n        (object_property\n          key: (identifier)\n          value: (number))))))\n\n================================================================================\nObject with array value\n================================================================================\n\nobj := {items: [1, 2, 3]}\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (object_literal\n    (object_property\n      key: (identifier)\n      value: (array_literal\n        (number)\n        (number)\n        (number)))))\n```\n\n3. Run `npm run test` - all tests should pass\n\n4. Verify object literals don't break function definitions:\n```ahk\nMyFunc() {\n    return 1\n}\n```\n\n5. Commit, push, update `rev` in `extension.toml`, delete `grammars/`, reinstall dev extension\n\n6. Test highlighting in Zed - verify:\n   - Object keys highlight as `@property`\n   - Colons and braces have appropriate highlighting\n   - Values inside objects highlight correctly (strings, numbers, identifiers)",
        "status": "done",
        "dependencies": [
          "16",
          "9"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:43:19.935Z"
      },
      {
        "id": "28",
        "title": "Add continuation section syntax to grammar",
        "description": "Parse AHK continuation sections where expressions/strings span multiple lines using parentheses. Support Join, LTrim, RTrim, and Comment options in the opening parenthesis line.",
        "details": "Update `grammar.js` to add continuation section rules:\n\n```javascript\n// Continuation section: multiline string/expression in parens\n// Format: var := (LTrim Join`n\n//   line1\n//   line2\n// )\ncontinuation_section: $ => seq(\n  '(',\n  optional($.continuation_options),\n  /\\n/,\n  $.continuation_body,\n  ')'\n),\n\n// Options on the opening paren line: LTrim, RTrim, Join, Comments, etc.\ncontinuation_options: $ => repeat1(choice(\n  $.continuation_option_ltrim,\n  $.continuation_option_rtrim,\n  $.continuation_option_join,\n  $.continuation_option_comments,\n  // Literal text options\n  /[^\\n)]+/\n)),\n\ncontinuation_option_ltrim: $ => token(prec(2, /LTrim/i)),\ncontinuation_option_rtrim: $ => token(prec(2, /RTrim/i)),\ncontinuation_option_join: $ => token(prec(2, seq(/Join/i, optional(/[^\\s)]+/)))),  // Join or Join`n, Join%A_Tab%, etc.\ncontinuation_option_comments: $ => token(prec(2, /Comments?/i)),\n\n// Body captures all lines until closing paren\ncontinuation_body: $ => repeat1(choice(\n  $.continuation_line,\n  $.comment,  // Allow comments if Comments option enabled\n)),\n\ncontinuation_line: $ => /[^\\n)][^\\n]*/,\n```\n\n**Key considerations:**\n\n1. **Continuation sections start with `(`** - This conflicts with expression grouping. Use `prec()` and ensure the newline after `(` distinguishes continuation from expression grouping.\n\n2. **Options are case-insensitive** - Use `/LTrim/i` pattern for case-insensitivity.\n\n3. **Join can have a custom separator** - `Join` alone means no separator, `Join\\`n` means newline, etc.\n\n4. **Add to _statement and _expression** - Per TREE_SITTER_NOTES.md, rules need to be in both for proper parsing at all levels.\n\nUpdate `_statement` and `_expression`:\n```javascript\n_statement: $ => choice(\n  $.continuation_section,  // Add before string\n  // ... existing choices\n),\n\n_expression: $ => choice(\n  $.continuation_section,  // Add here too\n  // ... existing choices\n),\n```\n\n**Conflicts to handle:**\n- Add `[$.continuation_section]` to conflicts if needed to resolve `(` ambiguity with function calls and expression grouping.\n- The newline requirement after `(` helps distinguish: `MyFunc(` expects args, `(\\n` starts continuation.\n\nUpdate `highlights.scm`:\n```scheme\n; Continuation sections\n(continuation_section \"(\" @punctuation.bracket)\n(continuation_section \")\" @punctuation.bracket)\n(continuation_option_ltrim) @keyword\n(continuation_option_rtrim) @keyword\n(continuation_option_join) @keyword\n(continuation_option_comments) @keyword\n(continuation_line) @string\n```\n\n**Alternative simpler approach** if full parsing is too complex:\n\n```javascript\n// Simpler: treat entire continuation as one token\ncontinuation_section: $ => token(seq(\n  '(',\n  optional(/[^\\n)]*/),  // options\n  /\\n/,\n  /([^)]*\\n)*/,  // body lines\n  ')'\n)),\n```\n\nThis captures the whole section without internal structure, which may be sufficient for syntax highlighting purposes.",
        "testStrategy": "1. Run `npm run generate` - verify no grammar generation errors\n\n2. Create `test/corpus/continuation.txt` with test cases:\n```\n================================================================================\nSimple continuation section\n================================================================================\n\nvar := (\n  line one\n  line two\n)\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (continuation_section\n    (continuation_body\n      (continuation_line)\n      (continuation_line))))\n\n================================================================================\nContinuation with LTrim\n================================================================================\n\nvar := (LTrim\n  trimmed line\n)\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (continuation_section\n    (continuation_options\n      (continuation_option_ltrim))\n    (continuation_body\n      (continuation_line))))\n\n================================================================================\nContinuation with Join option\n================================================================================\n\nvar := (Join`n\n  line1\n  line2\n)\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (identifier)\n  (operator)\n  (continuation_section\n    (continuation_options\n      (continuation_option_join))\n    (continuation_body\n      (continuation_line)\n      (continuation_line))))\n```\n\n3. Run `npm run test` - verify all continuation tests pass\n\n4. Test parsing manually with real AHK continuation examples:\n```ahk\nsql := (LTrim Join`n\n  SELECT *\n  FROM users\n  WHERE active = 1\n)\n\nhtml := (\n  <html>\n  <body>Hello</body>\n  </html>\n)\n```\n\n5. Run `npx tree-sitter parse test.ahk` to verify AST structure\n\n6. Update extension.toml rev, reinstall in Zed, verify continuation sections highlight correctly (body as string, options as keywords)",
        "status": "done",
        "dependencies": [
          "2",
          "7"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2025-12-26T22:36:59.656Z"
      },
      {
        "id": "29",
        "title": "Add query file validation to CI",
        "description": "Validate highlights.scm, brackets.scm, and other query files in CI to catch syntax errors and invalid node references before merge.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Add a CI step that runs `tree-sitter query` validation on all .scm files in languages/autohotkey/. This catches typos in node names (e.g., referencing `@funktoin` instead of `@function`) and invalid query syntax before they break highlighting in production.\n\nImplementation:\n1. Add step after parser generation: `npx tree-sitter query --test languages/autohotkey/highlights.scm`\n2. Validate all .scm files: highlights.scm, brackets.scm, indents.scm, textobjects.scm\n3. The --test flag validates syntax without needing a source file\n\nAlternative approach if tree-sitter query doesn't have --test:\n- Parse a sample .ahk file and apply queries, checking for warnings about unknown nodes",
        "testStrategy": "1. Introduce a deliberate typo in highlights.scm (e.g., `(identifer)` instead of `(identifier)`)\n2. Run CI locally or push to a branch\n3. Verify CI fails with clear error message about invalid node\n4. Fix typo, verify CI passes",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:41:32.038Z"
      },
      {
        "id": "30",
        "title": "Add sample AHK file parsing to CI",
        "description": "Parse real-world AHK scripts in CI to ensure grammar handles actual code without errors or unexpected parse failures.",
        "status": "cancelled",
        "dependencies": [],
        "priority": "medium",
        "details": "Create test/samples/ directory with representative AHK v1 scripts and add CI step to parse them.\n\nImplementation:\n1. Create test/samples/ directory\n2. Add 3-5 sample .ahk files covering different features:\n   - simple.ahk: basic hotkeys, functions, variables\n   - commands.ahk: common AHK commands (MsgBox, Send, etc.)\n   - complex.ahk: nested structures, expressions, edge cases\n3. Add CI step: `npx tree-sitter parse test/samples/*.ahk --quiet`\n4. The --quiet flag only outputs errors, making CI output clean\n\nThe parse command exits non-zero if parsing fails, which fails CI appropriately.",
        "testStrategy": "1. Create test/samples/ with sample files\n2. Run `npm run parse test/samples/*.ahk` locally - verify all parse\n3. Introduce syntax the grammar doesn't handle in a sample file\n4. Verify CI would fail (parse command exits non-zero)\n5. Fix or remove problematic syntax",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:42:59.285Z"
      },
      {
        "id": "31",
        "title": "Add Node.js version matrix to CI",
        "description": "Test across Node 18, 20, and 22 to ensure compatibility with all current LTS and latest versions.",
        "details": "Update CI workflow to use a matrix strategy for Node.js versions.\n\nImplementation in .github/workflows/ci.yml:\n```yaml\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18, 20, 22]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node-version }}\n          cache: 'npm'\n      # ... rest of steps\n```\n\nThis is free on public repos and catches version-specific issues early. Node 18 is current LTS, 20 is active LTS, 22 is latest.",
        "testStrategy": "1. Update ci.yml with matrix strategy\n2. Push to a branch and open PR\n3. Verify GitHub Actions shows 3 parallel jobs (Node 18, 20, 22)\n4. Verify all 3 pass\n5. Check that matrix failures are clearly labeled by Node version",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:41:10.455Z"
      },
      {
        "id": "32",
        "title": "Add Dependabot for dependency updates",
        "description": "Configure Dependabot to automatically create PRs when tree-sitter-cli and other dependencies have updates.",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "details": "Create .github/dependabot.yml to enable automatic dependency update PRs.\n\nImplementation:\n```yaml\nversion: 2\nupdates:\n  - package-ecosystem: \"npm\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    commit-message:\n      prefix: \"chore(deps)\"\n    labels:\n      - \"dependencies\"\n```\n\nBenefits:\n- Automatic PRs when tree-sitter-cli updates (new features, bug fixes)\n- Security updates for any vulnerable dependencies\n- Easy to review and merge or dismiss\n\nOptional: Add GitHub Actions ecosystem to also update action versions:\n```yaml\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n```",
        "testStrategy": "1. Create .github/dependabot.yml with config\n2. Commit and push to master\n3. Wait for Dependabot to activate (may take up to a day)\n4. Check repository Settings > Code security > Dependabot to verify enabled\n5. When first PR arrives, verify it updates correctly and CI passes",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:43:40.590Z"
      },
      {
        "id": "33",
        "title": "Add automated GitHub releases on version tags",
        "description": "Create GitHub releases automatically when version tags are pushed, including changelog generation and release notes.",
        "details": "Add release workflow that triggers on version tags (v*) and creates GitHub releases.\n\nImplementation in .github/workflows/release.yml:\n```yaml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Generate changelog\n        id: changelog\n        uses: orhun/git-cliff-action@v3\n        with:\n          args: --latest --strip header\n\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          body: ${{ steps.changelog.outputs.content }}\n          generate_release_notes: true\n```\n\nAlternative simpler approach without changelog tool:\n```yaml\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          generate_release_notes: true\n```\n\nThis uses GitHub's auto-generated release notes based on PR titles.\n\nNote: This is for later when publishing to Zed extension store becomes relevant.",
        "testStrategy": "1. Create .github/workflows/release.yml\n2. Commit and push to master\n3. Create and push a test tag: `git tag v0.1.0-test && git push origin v0.1.0-test`\n4. Verify GitHub Actions runs release workflow\n5. Check Releases page for new release with notes\n6. Delete test release and tag if desired",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2025-12-26T22:49:39.592Z"
      },
      {
        "id": "34",
        "title": "Add binary expression support to grammar",
        "description": "Add binary_expression rule to properly parse comparison and arithmetic expressions like `a > 0`, `x == 1`, `a + b`. Currently these produce ERROR nodes inside parenthesized_expression conditions.",
        "details": "The grammar currently has operators defined but no binary_expression rule to combine them with operands. Expressions like `if (a > 0)` parse the condition as `(identifier) (ERROR (operator) (number))`.\n\nNeed to add:\n```javascript\nbinary_expression: $ => prec.left(seq(\n  field('left', $._expression),\n  field('operator', $.operator),\n  field('right', $._expression)\n)),\n```\n\nConsider operator precedence levels for proper parsing of complex expressions like `a + b * c`.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "25"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T17:43:37.785Z"
      },
      {
        "id": "35",
        "title": "Add comma-style loop variants to grammar",
        "description": "Extend loop_statement to support AHK v1 comma-style loop variants: Loop Parse, Loop Files, Loop Read, Loop Reg.",
        "details": "Currently loop_statement only supports simple forms: `loop { }`, `loop N { }`, `loop expr { }`.\n\nAdd support for comma-style variants:\n- `loop, parse, InputVar, Delimiters` - parse loop\n- `loop, files, FilePattern` - file loop  \n- `loop, read, InputFile` - file read loop\n- `loop, reg, RootKey, Key` - registry loop\n\nGrammar addition:\n```javascript\nloop_statement: $ => seq(\n  'loop',\n  optional(choice(\n    field('count', choice($.number, $.identifier, $.parenthesized_expression)),\n    seq(',', $.loop_type, optional($.loop_arguments))\n  )),\n  field('body', $.statement_block)\n),\n\nloop_type: $ => choice('parse', 'files', 'file', 'read', 'reg'),\n\nloop_arguments: $ => repeat1(choice(',', $.identifier, $.string, /[^\\s{}\\n]+/)),\n```",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "25"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2025-12-26T22:46:18.605Z"
      },
      {
        "id": "36",
        "title": "Add braceless control flow support",
        "description": "Allow if/else/while/loop/for statements to have single-statement bodies without braces by changing body requirements from `statement_block` to `choice(statement_block, _statement)`.",
        "details": "## Implementation Steps\n\n### 1. Modify grammar.js control flow rules\n\nChange each control flow statement to accept either a braced block or a single statement:\n\n**if_statement (line 111-116):**\n```javascript\nif_statement: $ => prec.right(seq(\n  'if',\n  field('condition', $.parenthesized_expression),\n  field('consequence', choice($.statement_block, $._statement)),\n  optional(field('alternative', $.else_clause))\n)),\n```\n\n**else_clause (line 118-121):**\n```javascript\nelse_clause: $ => seq(\n  'else',\n  choice($.if_statement, $.statement_block, $._statement)\n),\n```\n\n**while_statement (line 123-127):**\n```javascript\nwhile_statement: $ => seq(\n  'while',\n  field('condition', $.parenthesized_expression),\n  field('body', choice($.statement_block, $._statement))\n),\n```\n\n**loop_statement (line 129-133):**\n```javascript\nloop_statement: $ => seq(\n  'loop',\n  optional(field('count', choice($.number, $.identifier))),\n  field('body', choice($.statement_block, $._statement))\n),\n```\n\n**for_statement (line 135-142):**\n```javascript\nfor_statement: $ => seq(\n  'for',\n  field('key', $.identifier),\n  optional(seq(',', field('value', $.identifier))),\n  'in',\n  field('collection', $._expression),\n  field('body', choice($.statement_block, $._statement))\n),\n```\n\n### 2. Handle dangling else ambiguity\n\nThe existing `prec.right` on `if_statement` should handle the classic dangling else problem by associating `else` with the nearest `if`. However, verify this with test cases. If conflicts arise, add to the conflicts array:\n\n```javascript\nconflicts: $ => [\n  [$.parameter, $._expression],\n  [$.if_statement],  // May need this for dangling else\n],\n```\n\n### 3. Consider try/catch/finally\n\nFor consistency, apply the same pattern to try/catch/finally (lines 144-160):\n\n```javascript\ntry_statement: $ => seq(\n  'try',\n  field('body', choice($.statement_block, $._statement)),\n  optional($.catch_clause),\n  optional($.finally_clause)\n),\n\ncatch_clause: $ => seq(\n  'catch',\n  optional(field('exception', $.identifier)),\n  field('body', choice($.statement_block, $._statement))\n),\n\nfinally_clause: $ => seq(\n  'finally',\n  field('body', choice($.statement_block, $._statement))\n),\n```\n\n### 4. Potential issues to watch for\n\n1. **Parser size increase**: Adding more choices increases parser states. Monitor with `wc -l src/parser.c`\n2. **Ambiguity with expressions**: Single statements like `x := 1` after `if (cond)` should parse correctly since `_statement` includes `assignment_expression`\n3. **Newline handling**: AHK traditionally uses newlines as statement terminators. The `extras: [/\\s/]` allows whitespace between keywords and bodies, but ensure braceless statements parse correctly across newlines\n4. **Indents.scm**: The current indents.scm uses `statement_block` for indentation. Single statements won't auto-indent without additional rules",
        "testStrategy": "## Test Strategy\n\n### 1. Generate parser and verify no conflicts\n\n```bash\nnpm run generate\n```\n\nCheck for conflict warnings in output. If conflicts appear, add appropriate entries to the `conflicts` array.\n\n### 2. Add test cases to test/corpus/control_flow.txt\n\nAdd these test cases after the existing ones:\n\n```\n================================================================================\nBraceless if statement\n================================================================================\n\nif (x)\n    y := 1\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (if_statement\n    condition: (parenthesized_expression\n      (identifier))\n    consequence: (assignment_expression\n      left: (identifier)\n      right: (number))))\n\n================================================================================\nBraceless if-else statement\n================================================================================\n\nif (x)\n    a := 1\nelse\n    b := 2\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (if_statement\n    condition: (parenthesized_expression\n      (identifier))\n    consequence: (assignment_expression\n      left: (identifier)\n      right: (number))\n    alternative: (else_clause\n      (assignment_expression\n        left: (identifier)\n        right: (number)))))\n\n================================================================================\nBraceless while statement\n================================================================================\n\nwhile (running)\n    DoWork()\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (while_statement\n    condition: (parenthesized_expression\n      (identifier))\n    body: (function_call\n      name: (identifier))))\n\n================================================================================\nBraceless loop statement\n================================================================================\n\nloop 5\n    count += 1\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (loop_statement\n    count: (number)\n    body: (assignment_expression\n      left: (identifier)\n      right: (number))))\n\n================================================================================\nBraceless for statement\n================================================================================\n\nfor item in collection\n    Process(item)\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (for_statement\n    key: (identifier)\n    collection: (identifier)\n    body: (function_call\n      name: (identifier)\n      (argument_list\n        (identifier)))))\n\n================================================================================\nDangling else associates with nearest if\n================================================================================\n\nif (a)\n    if (b)\n        x := 1\n    else\n        x := 2\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (if_statement\n    condition: (parenthesized_expression\n      (identifier))\n    consequence: (if_statement\n      condition: (parenthesized_expression\n        (identifier))\n      consequence: (assignment_expression\n        left: (identifier)\n        right: (number))\n      alternative: (else_clause\n        (assignment_expression\n          left: (identifier)\n          right: (number))))))\n\n================================================================================\nMixed braced and braceless\n================================================================================\n\nif (x) {\n    a := 1\n} else\n    b := 2\n\n--------------------------------------------------------------------------------\n\n(source_file\n  (if_statement\n    condition: (parenthesized_expression\n      (identifier))\n    consequence: (statement_block\n      (block\n        (assignment_expression\n          left: (identifier)\n          right: (number))))\n    alternative: (else_clause\n      (assignment_expression\n        left: (identifier)\n        right: (number)))))\n```\n\n### 3. Run tree-sitter tests\n\n```bash\nnpm run test\n```\n\nAll existing tests should continue to pass, and new braceless tests should pass.\n\n### 4. Manual parsing verification\n\nCreate a test file and parse it:\n\n```bash\necho 'if (x)\n    y := 1\nelse if (z)\n    y := 2\nelse\n    y := 3' > test_braceless.ahk\n\nnpx tree-sitter parse test_braceless.ahk\n```\n\n### 5. Verify highlighting in Zed\n\nAfter pushing changes and updating `rev` in extension.toml:\n1. Reinstall dev extension in Zed\n2. Open an AHK file with braceless control flow\n3. Verify keywords (`if`, `else`, `while`, etc.) highlight correctly\n4. Verify body statements highlight correctly",
        "status": "done",
        "dependencies": [
          "25"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T21:28:49.400Z"
      },
      {
        "id": "37",
        "title": "Add highlight tests for syntax highlighting with pragmatic coverage",
        "description": "Create tree-sitter highlight test files in test/highlight/ directory to verify syntax highlighting queries work correctly. Tests use source code with specially-formatted comments (^ carets and <- arrows) to assert expected highlight groups at specific columns.",
        "details": "Tree-sitter highlight tests use source code files with assertion comments to verify highlights.scm queries. Tests go in `test/highlight/` directory with `.ahk` extension.\n\n## Test Syntax\n\n- **Caret (^)**: Tests the column directly above it on the most recent non-comment line\n- **Arrow (<-)**: Tests the column where the comment `;` appears\n- **Negation (!)**: Asserts something is NOT a particular highlight (e.g., `; <- !variable`)\n\n## Files to Create\n\n### 1. test/highlight/operators.ahk\nTest assignment, binary, unary, and ternary operators:\n\n```ahk\nx := 1\n; ^ operator\n\nx += 1\n; ^ operator\n\nresult := a + b\n;           ^ operator\n\nresult := a && b\n;           ^^ operator\n\nresult := a || b\n;           ^^ operator\n\nresult := !x\n;         ^ operator\n\nresult := x ? \"yes\" : \"no\"\n;           ^ operator\n;                   ^ operator\n```\n\nCover: `:=`, `+=`, `-=`, `*=`, `/=`, `.=`, `+`, `-`, `*`, `/`, `//`, `%`, `**`, `&&`, `||`, `!`, `~`, `?`, `:`, `==`, `!=`, `<`, `>`, `<=`, `>=`, `<<`, `>>`, `|`, `&`, `^`\n\nKeyword operators: `and`, `or`, `not` should get `; ^^ keyword.operator`\n\n### 2. test/highlight/functions.ahk\nTest function definitions, function calls, method calls, and builtin commands:\n\n```ahk\nMyFunc() {\n; <- function\n}\n\nMyFunc(x, y) {\n; <- function\n}\n\nresult := MyFunc()\n;         ^^^^^^ function\n\nresult := MyFunc(42)\n;         ^^^^^^ function\n\nobj.method()\n;   ^^^^^^ function.method\n\nobj.method(arg)\n;   ^^^^^^ function.method\n\nMsgBox, Hello\n; <- function.builtin\n\nSleep, 1000\n; <- function.builtin\n\nRun, notepad.exe\n; <- function.builtin\n```\n\nCover: function definitions (with/without params), function calls (with/without args), nested calls, method calls on objects, chained method calls, builtin commands (MsgBox, Sleep, Run, Send, SetTimer, Gosub)\n\n### 3. test/highlight/variables.ahk\nTest regular variables, builtin variables, parameters, and properties:\n\n```ahk\nmyVar := 1\n; <- variable\n\nx := myVar\n;    ^^^^^ variable\n\nA_ScriptDir\n; <- variable.special\n\npath := A_ScriptDir\n;       ^^^^^^^^^^^ variable.special\n\nA_Now\n; <- variable.special\n\nA_TickCount\n; <- variable.special\n\nClipboard\n; <- variable.special\n\nErrorLevel\n; <- variable.special\n\nMsgBox, %myVar%\n;        ^^^^^ variable\n\nMsgBox, %A_ScriptDir%\n;        ^^^^^^^^^^^ variable.special\n\nobj.property\n;   ^^^^^^^^ property\n\nobj.prop := 10\n;   ^^^^ property\n\nthis\n; <- variable.builtin\n\nbase\n; <- variable.builtin\n```\n\nCover: identifier as variable, builtin variables (A_ScriptDir, A_Now, A_TickCount, A_AhkVersion, A_ComSpec, Clipboard, ErrorLevel), variable references in commands (%var%), properties on objects, `this` and `base` keywords\n\n### 4. test/highlight/keywords.ahk\nTest control flow keywords:\n\n```ahk\nif (x) {\n; <- keyword\n}\n\nif (x) {\n} else {\n; <- keyword\n}\n\nwhile (running) {\n; <- keyword\n}\n\nloop {\n; <- keyword\n}\n\nloop 10 {\n; <- keyword\n}\n\nfor item in collection {\n; <- keyword\n;      ^^ keyword\n}\n\ntry {\n; <- keyword\n} catch e {\n; <- keyword\n} finally {\n; <- keyword\n}\n\nreturn\n; <- keyword\n\nbreak\n; <- keyword\n\ncontinue\n; <- keyword\n\nthrow\n; <- keyword\n```\n\nCover: `if`, `else`, `while`, `loop`, `for`, `in`, `try`, `catch`, `finally`, `return`, `break`, `continue`, `throw`, `class`, `extends`, `static`\n\n## Implementation Notes\n\n- Use `;` for AHK comments (not `//`)\n- Carets must align exactly with the character column being tested\n- Multiple consecutive `^` characters test multiple columns\n- Keep tests focused on high-value highlighting scenarios\n- Each test file should have a logical grouping\n- Test both positive assertions and a few negative assertions where valuable",
        "testStrategy": "1. Create the test/highlight/ directory: `mkdir -p test/highlight`\n\n2. Create each test file (operators.ahk, functions.ahk, variables.ahk, keywords.ahk) with the assertion comments\n\n3. Run highlight tests: `npx tree-sitter test` (should automatically detect and run highlight tests in test/highlight/)\n\n4. If tree-sitter test doesn't run highlight tests by default, use: `npx tree-sitter highlight test/highlight/operators.ahk` to manually verify highlighting output\n\n5. Verify each test file passes without errors:\n   - All positive assertions (^ keyword, ^ operator, etc.) should match\n   - All negative assertions (^ !variable, etc.) should pass\n   - No unmatched or unexpected highlight groups\n\n6. Cross-reference with highlights.scm to ensure test coverage matches defined queries:\n   - Check that major highlight groups (@operator, @function, @variable.special, @keyword, @function.builtin, @function.method, @property, @variable.builtin) all have test coverage\n\n7. Manual spot-check: Open test files in Zed after pushing to verify visual highlighting matches assertions",
        "status": "done",
        "dependencies": [
          "5",
          "10"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-26T21:15:18.709Z"
      },
      {
        "id": "38",
        "title": "Publish extension to Zed extension store",
        "description": "Submit the AutoHotkey extension to the official Zed extension registry by opening a PR to zed-industries/extensions.",
        "details": "## Prerequisites (already met)\n- extension.toml configured correctly\n- MIT LICENSE file at root (accepted by Zed)\n- Public GitHub repository\n\n## Steps to publish\n\n1. Fork https://github.com/zed-industries/extensions to personal GitHub account (not organization - allows Zed staff to push fixes)\n\n2. Clone the fork locally\n\n3. Add extension as git submodule (HTTPS URL required, not SSH):\n   ```bash\n   git submodule add https://github.com/alfredomtx/tree-sitter-autohotkey extensions/autohotkey\n   ```\n\n4. Add entry to top-level `extensions.toml`:\n   ```toml\n   [autohotkey]\n   submodule = \"extensions/autohotkey\"\n   version = \"0.1.0\"\n   ```\n\n5. Run `pnpm sort-extensions` to ensure proper file ordering\n\n6. Commit and push to fork\n\n7. Open PR to zed-industries/extensions\n\n## CI Validation\nThe PR will be validated for:\n- Valid license file (MIT ✓)\n- Version consistency between extension.toml and extensions.toml\n- HTTPS submodule URL\n- Proper file sorting\n\n## References\n- https://zed.dev/docs/extensions/developing-extensions\n- https://github.com/zed-industries/extensions",
        "testStrategy": "1. Verify PR passes CI checks\n2. After merge, search for \"AutoHotkey\" in Zed's extension panel\n3. Install from store and verify syntax highlighting works",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-26T23:09:12.847Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-26T23:09:12.849Z",
      "taskCount": 38,
      "completedCount": 37,
      "tags": [
        "master"
      ]
    }
  }
}